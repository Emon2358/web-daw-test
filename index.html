<!DOCTYPE html>
<html lang="ja" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web ZMUSIC (X68k Sampler Simulator)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* HTML/Bodyをフルハイトに */
        html, body {
            height: 100%;
            overflow: hidden; /* メインのスクロールを無効化 */
        }
        /* スクロールバーのスタイル（オプション） */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* タブレット/PC用のグリッドレイアウト */
        @media (min-width: 768px) {
            .main-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                gap: 0.75rem; /* gap-3 */
            }
        }
        /* スマホ用のタブUI */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body class="font-mono bg-gray-900 text-gray-200 h-full flex flex-col p-2 sm:p-4 overflow-hidden">

    <div class="w-full max-w-7xl mx-auto flex flex-col h-full">

        <header class="mb-3">
            <div class="flex flex-wrap items-center justify-between gap-2">
                <h1 class="text-xl sm:text-2xl font-bold text-green-400">Web ZMUSIC (X68k Simulator)</h1>
                <div class="flex items-center gap-2">
                    <button id="playButton" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-md shadow-lg text-white font-bold transition-all">
                        PLAY (BAT)
                    </button>
                    <button id="stopButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md shadow-lg text-white font-bold transition-all">
                        STOP (BAT)
                    </button>
                </div>
            </div>
            <div class="text-sm text-gray-400 mt-1" id="promptDisplay">A:\CD_WORKS\gabba\></div>
        </header>

        <div class="flex-1 flex flex-col md:flex-row gap-3 overflow-hidden">

            <div class="w-full md:w-1/3 flex flex-col gap-3 overflow-y-auto">
                
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">Directory / Files</h2>
                    <div class="flex flex-col gap-2 text-sm">
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Dir:</label>
                            <input type="text" id="dirInput" value="A:\CD_WORKS\gabba\" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Play BAT:</label>
                            <input type="text" id="playBatInput" value="gabba.BAT" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Stop BAT:</label>
                            <input type="text" id="stopBatInput" value="STOP.BAT" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">1. ソース音声のロード</h2>
                    <p class="text-xs text-gray-400 mb-2">サンプリング（切り出し）用のWAV, MP3, M4A, FLAC等をロードします。</p>
                    <input type="file" id="sourceAudioUpload" multiple accept="audio/*" class="text-sm file:mr-4 file:py-1 file:px-2 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                    <div id="sourceAudioList" class="mt-2 bg-gray-900 rounded-md p-2 h-20 overflow-y-auto text-sm border border-gray-700">
                        <span class="text-gray-500">... (ここにソース音声) ...</span>
                    </div>
                </div>

                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">2. 波形サンプラー</h2>
                    <div class="relative mb-2">
                        <canvas id="waveformCanvas" class="w-full h-24 bg-black rounded-md cursor-crosshair"></canvas>
                        <div id="selectionInfo" class="absolute bottom-1 left-1 text-xs bg-black bg-opacity-50 text-white px-1 py-0.5 rounded">
                            Drag: Select / Wheel: Pan / Ctrl+Wheel: Zoom
                        </div>
                        <div class="absolute top-1 right-1 flex gap-1">
                            <button id="zoomInButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-lg leading-none">-</button>
                            <button id="zoomOutButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-lg leading-none">+</button>
                            <button id="zoomAllButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-xs leading-none">All</button>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <input type="text" id="sampleSaveName" placeholder="保存名 (例: melo1.m44)" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-green-500">
                        <button id="saveSampleButton" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded-md text-white font-semibold text-sm">切り出し保存</button>
                    </div>
                </div>

                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">3. マイク録音</h2>
                    <div class="flex gap-2">
                        <input type="text" id="recordSaveName" placeholder="保存名 (例: voice1.m44)" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-green-500">
                        <button id="recordButton" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded-md text-white font-semibold text-sm w-20">● REC</button>
                    </div>
                </div>

                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">4. サンプルバンク (CFGから参照)</h2>
                    <label class="block mb-2">
                        <span class="text-xs text-gray-400">サンプル (WAV, MP3等) を直接バンクにロードします。</span>
                        <input type="file" id="bankAudioUpload" multiple accept="audio/*" class="text-sm w-full mt-1 file:mr-4 file:py-1 file:px-2 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                    </label>
                    <div id="sampleBankList" class="mt-2 bg-gray-900 rounded-md p-2 h-24 overflow-y-auto text-sm border border-gray-700">
                        <span class="text-gray-500">... (ここにサンプル) ...</span>
                    </div>
                </div>

            </div>

            <div class="flex-1 flex flex-col overflow-hidden">
                
                <div class="flex flex-wrap gap-2 mb-3">
                    <button id="saveProjectButton" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-semibold text-sm">Save Project</button>
                    <label class="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded-md text-white font-semibold text-sm cursor-pointer">
                        <span>Load Project</span>
                        <input type="file" id="loadProjectInput" accept=".json" class="hidden">
                    </label>
                </div>

                <div class="md:hidden border-b border-gray-700 mb-2">
                    <nav class="flex -mb-px" id="tabContainer">
                        <button data-tab="tab1" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.BAT
                        </button>
                        <button data-tab="tab2" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            STOP.BAT
                        </button>
                        <button data-tab="tab3" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.cfg
                        </button>
                        <button data-tab="tab4" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.zms
                        </button>
                    </nav>
                </div>

                <div class="flex-1 main-grid overflow-hidden">
                    
                    <div id="tab1" class="tab-content flex flex-col h-full min-h-[150px]">
                        <label id="playBatLabel" for="batEditor" class="text-sm text-green-400 mb-1 block">gabba.BAT</label>
                        <textarea id="batEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">pcm8pp -c8 -f7
zmusic -a -p3000
zmusic -d
zp gabba.zms
</textarea>
                    </div>

                    <div id="tab2" class="tab-content flex flex-col h-full min-h-[150px]">
                        <label id="stopBatLabel" for="stopBatEditor" class="text-sm text-green-400 mb-1 block">STOP.BAT</label>
                        <textarea id="stopBatEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">zp -s
zmusic -r
pcm8pp -r
</textarea>
                    </div>

                    <div id="tab3" class="tab-content flex flex-col h-full min-h-[200px]">
                        <label id="cfgLabel" for="cfgEditor" class="text-sm text-green-400 mb-1 block">gabba.cfg</label>
                        <textarea id="cfgEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">/* ADPCM BANK1
.adpcm_bank=1
.o2c = kick.m44
.o2d = snar.m44
.o2f = hhc.m44
.o2f+= hho.m44
.o2a = clap.m44
.o2b = crash.m44
.o3c = melo1.m44
.o3d = melo2.m44
.o4c = voice1.m44
.o4d = voice2.m44
</textarea>
                    </div>

                    <div id="tab4" class="tab-content flex flex-col h-full min-h-[200px]">
                        <label id="zmsLabel" for="zmsEditor" class="text-sm text-green-400 mb-1 block">gabba.zms</label>
                        <textarea id="zmsEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">t140
[L
A o4 l8 c r c r c r c r
B o4 l8 r r d r r r d r
C o4 l8 r f r f r f r f
L]</textarea>
                    </div>
                </div>
            </div>
        </div>

        <footer class="h-20 md:h-16 mt-3 overflow-y-auto bg-gray-800 p-2 rounded-md shadow-inner text-sm" id="consoleLog">
            <span class="text-gray-400">> Web ZMUSIC Simulator initialized. Ready.</span><br>
        </footer>
    </div>

    <script>
        // --- グローバル変数 ---
        let audioContext;
        let mediaRecorder;
        let recordedChunks = [];
        let audioBuffers = new Map(); // サンプルバンク (filename -> AudioBuffer)
        let sourceAudioBuffers = new Map(); // ソース音声 (filename -> AudioBuffer)
        let mmlTimeouts = []; // MML再生中のタイマー
        let mmlLoopTimeout = null; // ループ再生用のタイマー
        let isMMLPlaying = false;
        
        // 波形サンプラー用
        let currentSamplerBuffer = null;
        let selectionStartSample = 0;
        let selectionEndSample = 0;
        let isDragging = false;
        let zoomLevel = 1; 
        let viewOffset = 0; // 0.0 ~ 1.0 (パーセンテージ)
        
        // --- DOM取得 ---
        const $ = (selector) => document.getElementById(selector);
        const consoleLog = $('consoleLog');
        const playButton = $('playButton');
        const stopButton = $('stopButton');
        const recordButton = $('recordButton');
        const sourceAudioUpload = $('sourceAudioUpload');
        const bankAudioUpload = $('bankAudioUpload');
        const sourceAudioList = $('sourceAudioList');
        const sampleBankList = $('sampleBankList');
        const dirInput = $('dirInput');
        const playBatInput = $('playBatInput');
        const stopBatInput = $('stopBatInput');
        const playBatLabel = $('playBatLabel');
        const stopBatLabel = $('stopBatLabel');
        const cfgLabel = $('cfgLabel');
        const zmsLabel = $('zmsLabel');
        const batEditor = $('batEditor');
        const stopBatEditor = $('stopBatEditor');
        const cfgEditor = $('cfgEditor');
        const zmsEditor = $('zmsEditor');
        const promptDisplay = $('promptDisplay');
        const saveProjectButton = $('saveProjectButton');
        const loadProjectInput = $('loadProjectInput');
        const recordSaveName = $('recordSaveName');
        
        // 波形サンプラー DOM
        const waveformCanvas = $('waveformCanvas');
        const canvasCtx = waveformCanvas.getContext('2d');
        const selectionInfo = $('selectionInfo');
        const sampleSaveName = $('sampleSaveName');
        const saveSampleButton = $('saveSampleButton');
        const zoomInButton = $('zoomInButton');
        const zoomOutButton = $('zoomOutButton');
        const zoomAllButton = $('zoomAllButton');

        // --- ログ関数 ---
        function log(message, type = 'info') {
            const color = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-green-400' : 'text-gray-400');
            consoleLog.innerHTML += `<span class="${color}">> ${message}</span><br>`;
            consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        // --- 1. オーディオ初期化 (最重要) ---
        async function initAudio() {
            if (audioContext && audioContext.state === 'running') {
                return true; // 既に実行中
            }
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (audioContext.state !== 'running') {
                    throw new Error('AudioContext is not running.');
                }
                return true;
            } catch (e) {
                log(`AudioContextの初期化/再開に失敗しました: ${e.message}`, 'error');
                return false;
            }
        }
        
        // --- 2. 音声ファイル処理 ---
        async function decodeAudioFile(file) {
            if (!(await initAudio())) return null;
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        resolve({ name: file.name, buffer: audioBuffer });
                    } catch (err) {
                        log(`デコード失敗: ${file.name} - ${err.message}`, 'error');
                        reject(err);
                    }
                };
                reader.onerror = (err) => {
                    log(`ファイル読み込み失敗: ${file.name}`, 'error');
                    reject(err);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function updateSourceAudioList() {
            sourceAudioList.innerHTML = '';
            if (sourceAudioBuffers.size === 0) {
                sourceAudioList.innerHTML = '<span class="text-gray-500">... (ここにソース音声) ...</span>';
                return;
            }
            sourceAudioBuffers.forEach((buffer, name) => {
                const div = document.createElement('div');
                div.className = 'p-1 hover:bg-gray-700 cursor-pointer text-blue-300';
                div.textContent = `${name} (${buffer.duration.toFixed(2)}s)`;
                div.onclick = () => loadSourceToSampler(name);
                sourceAudioList.appendChild(div);
            });
        }
        
        function updateSampleBankList() {
            sampleBankList.innerHTML = '';
            if (audioBuffers.size === 0) {
                sampleBankList.innerHTML = '<span class="text-gray-500">... (ここにサンプル) ...</span>';
                return;
            }
            audioBuffers.forEach((buffer, name) => {
                const div = document.createElement('div');
                div.className = 'p-1 hover:bg-gray-700 cursor-pointer text-green-300 flex justify-between items-center';
                const span = document.createElement('span');
                span.textContent = `${name} (${buffer.duration.toFixed(2)}s)`;
                const playBtn = document.createElement('button');
                playBtn.textContent = '▶';
                playBtn.className = 'text-xs px-1 rounded bg-blue-500 hover:bg-blue-400';
                playBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!(await initAudio())) return;
                    playSample(buffer);
                };
                div.appendChild(span);
                div.appendChild(playBtn);
                sampleBankList.appendChild(div);
            });
        }

        sourceAudioUpload.onchange = async (e) => {
            if (!(await initAudio())) return;
            log('ソース音声のロード中...', 'info');
            for (const file of e.target.files) {
                try {
                    const { name, buffer } = await decodeAudioFile(file);
                    sourceAudioBuffers.set(name, buffer);
                    log(`Loaded source audio: ${name}`, 'success');
                } catch (err) {}
            }
            updateSourceAudioList();
            sourceAudioUpload.value = '';
        };

        bankAudioUpload.onchange = async (e) => {
            if (!(await initAudio())) return;
            log('サンプルバンクへのロード中...', 'info');
            for (const file of e.target.files) {
                try {
                    const { name, buffer } = await decodeAudioFile(file);
                    audioBuffers.set(name, buffer);
                    log(`Loaded to bank: ${name}`, 'success');
                } catch (err) {}
            }
            updateSampleBankList();
            bankAudioUpload.value = '';
        };

        function addAudioBufferToBank(buffer, name) {
            if (!name) {
                log('ファイル名が指定されていません。', 'error');
                return;
            }
            audioBuffers.set(name, buffer);
            updateSampleBankList();
            log(`「${name}」をサンプルバンクに保存しました。`, 'success');
        }

        // --- 3. 波形サンプラー ---
        function loadSourceToSampler(name) {
            const buffer = sourceAudioBuffers.get(name);
            if (!buffer) {
                log(`ソース音声が見つかりません: ${name}`, 'error');
                return;
            }
            currentSamplerBuffer = buffer;
            sampleSaveName.value = `SMPL_${name.split('.')[0]}.m44`;
            selectionStartSample = 0;
            selectionEndSample = buffer.length;
            zoomLevel = 1;
            viewOffset = 0;
            drawWaveform();
            log(`サンプラーにロード: ${name}`, 'info');
        }
        
        function drawWaveform() {
            if (!currentSamplerBuffer || !canvasCtx) return;

            const data = currentSamplerBuffer.getChannelData(0);
            const w = waveformCanvas.width;
            const h = waveformCanvas.height;
            canvasCtx.fillStyle = '#000000';
            canvasCtx.fillRect(0, 0, w, h);

            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = Math.floor(totalSamples / zoomLevel);
            const startSample = Math.max(0, Math.floor(totalSamples * viewOffset));
            const endSample = Math.min(totalSamples, startSample + viewSamples);

            canvasCtx.lineWidth = 1;
            canvasCtx.strokeStyle = '#34d399'; // 明るい緑
            canvasCtx.beginPath();

            const step = Math.max(1, Math.floor(viewSamples / w));
            
            for (let i = 0; i < w; i++) {
                const sampleIndex = startSample + Math.floor((i / w) * viewSamples);
                let min = 1.0, max = -1.0;
                for(let j = 0; j < step; j++) {
                    const s = data[sampleIndex + j];
                    if (s === undefined) continue;
                    if (s < min) min = s;
                    if (s > max) max = s;
                }
                const y_max = (max * 0.5 + 0.5) * h;
                const y_min = (min * 0.5 + 0.5) * h;
                canvasCtx.moveTo(i, y_max);
                canvasCtx.lineTo(i, y_min);
            }
            canvasCtx.stroke();

            // 選択範囲の描画
            const selStartPixel = ((selectionStartSample - startSample) / viewSamples) * w;
            const selEndPixel = ((selectionEndSample - startSample) / viewSamples) * w;

            if (selEndPixel > selStartPixel) {
                canvasCtx.fillStyle = 'rgba(74, 222, 128, 0.4)'; // 明るい緑 (半透明)
                canvasCtx.fillRect(selStartPixel, 0, selEndPixel - selStartPixel, h);
            }
        }
        
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === waveformCanvas) {
                    const rect = entry.contentRect;
                    if (rect.width > 0 && rect.height > 0) {
                        waveformCanvas.width = rect.width;
                        waveformCanvas.height = rect.height;
                        drawWaveform();
                    }
                }
            }
        });
        resizeObserver.observe(waveformCanvas);

        waveformCanvas.onmousedown = (e) => {
            if (!currentSamplerBuffer) return;
            isDragging = true;
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pixelRatio = x / waveformCanvas.width;
            
            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = totalSamples / zoomLevel;
            const startSample = totalSamples * viewOffset;
            
            selectionStartSample = startSample + Math.floor(pixelRatio * viewSamples);
            selectionEndSample = selectionStartSample;
            drawWaveform();
        };

        waveformCanvas.onmousemove = (e) => {
            if (!isDragging || !currentSamplerBuffer) return;
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pixelRatio = x / waveformCanvas.width;

            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = totalSamples / zoomLevel;
            const startSample = totalSamples * viewOffset;

            selectionEndSample = startSample + Math.floor(pixelRatio * viewSamples);
            
            // 選択範囲の開始と終了が逆転した場合の処理
            const [start, end] = [selectionStartSample, selectionEndSample].sort((a,b) => a - b);
            
            drawWaveform(); // 常に再描画
            
            // 選択範囲をハイライト
            const selStartPixel = ((start - startSample) / viewSamples) * waveformCanvas.width;
            const selEndPixel = ((end - startSample) / viewSamples) * waveformCanvas.width;
            if (selEndPixel > selStartPixel) {
                canvasCtx.fillStyle = 'rgba(74, 222, 128, 0.4)';
                canvasCtx.fillRect(selStartPixel, 0, selEndPixel - selStartPixel, waveformCanvas.height);
            }
        };

        window.onmouseup = () => {
            if (isDragging) {
                isDragging = false;
                // 選択範囲を確定
                if (selectionEndSample < selectionStartSample) {
                    [selectionStartSample, selectionEndSample] = [selectionEndSample, selectionStartSample];
                }
                drawWaveform();
            }
        };

        waveformCanvas.onwheel = (e) => {
            e.preventDefault();
            if (!currentSamplerBuffer) return;

            const totalSamples = currentSamplerBuffer.length;

            if (e.ctrlKey) {
                // ズーム
                const rect = waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const mousePosRatio = x / waveformCanvas.width;
                const delta = e.deltaY < 0 ? 1.5 : 1 / 1.5;
                const newZoomLevel = Math.max(1, Math.min(zoomLevel * delta, totalSamples / 100)); // 最小100サンプル
                if (newZoomLevel === zoomLevel) return;
                
                const viewSamples = totalSamples / zoomLevel;
                const mouseSample = (totalSamples * viewOffset) + (mousePosRatio * viewSamples);
                zoomLevel = newZoomLevel;
                const newViewSamples = totalSamples / zoomLevel;
                viewOffset = (mouseSample - (mousePosRatio * newViewSamples)) / totalSamples;

            } else {
                // パン
                const delta = e.deltaY > 0 ? 0.05 : -0.05;
                viewOffset += delta / zoomLevel;
            }

            const maxViewOffset = 1.0 - (1.0 / zoomLevel);
            viewOffset = Math.max(0, Math.min(viewOffset, maxViewOffset));
            drawWaveform();
        };

        zoomInButton.onclick = () => { // - (縮小)
            if (!currentSamplerBuffer) return;
            zoomLevel = Math.max(1, zoomLevel / 1.5);
            viewOffset = Math.min(viewOffset, 1.0 - (1.0 / zoomLevel));
            drawWaveform();
        };
        zoomOutButton.onclick = () => { // + (拡大)
            if (!currentSamplerBuffer) return;
            const maxZoom = Math.max(1, currentSamplerBuffer.length / 100);
            zoomLevel = Math.min(maxZoom, zoomLevel * 1.5);
            drawWaveform();
        };
        zoomAllButton.onclick = () => {
            if (!currentSamplerBuffer) return;
            zoomLevel = 1;
            viewOffset = 0;
            drawWaveform();
        };

        saveSampleButton.onclick = async () => {
            if (!currentSamplerBuffer || selectionStartSample === selectionEndSample || !sampleSaveName.value) {
                log('ソース、選択範囲、または保存名がありません。', 'error');
                return;
            }
            if (!(await initAudio())) return;

            const start = Math.min(selectionStartSample, selectionEndSample);
            const end = Math.max(selectionStartSample, selectionEndSample);
            const length = end - start;
            if (length <= 0) return;

            const channels = currentSamplerBuffer.numberOfChannels;
            const rate = currentSamplerBuffer.sampleRate;

            try {
                const newBuffer = audioContext.createBuffer(channels, length, rate);
                for (let i = 0; i < channels; i++) {
                    const oldData = currentSamplerBuffer.getChannelData(i);
                    const newData = newBuffer.getChannelData(i);
                    newData.set(oldData.subarray(start, end));
                }
                addAudioBufferToBank(newBuffer, sampleSaveName.value);
            } catch (e) {
                log(`切り出しに失敗しました: ${e.message}`, 'error');
            }
        };

        // --- 4. マイク録音 ---
        recordButton.onclick = async () => {
            if (!(await initAudio())) return;
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                recordButton.textContent = '● REC';
                recordButton.classList.remove('animate-pulse', 'bg-red-800');
                log('録音を停止しました。', 'info');
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];
                    mediaRecorder.ondataavailable = (e) => e.data.size > 0 && recordedChunks.push(e.data);
                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(recordedChunks, { type: 'audio/wav' });
                        const arrayBuffer = await blob.arrayBuffer();
                        if (!(await initAudio())) return;
                        try {
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            const saveName = recordSaveName.value || `REC_${new Date().toISOString()}.wav`;
                            addAudioBufferToBank(audioBuffer, saveName);
                        } catch(e) {
                            log(`録音データのデコードに失敗しました: ${e.message}`, 'error');
                        }
                        stream.getTracks().forEach(track => track.stop());
                    };
                    mediaRecorder.start();
                    recordButton.textContent = '■ STOP';
                    recordButton.classList.add('animate-pulse', 'bg-red-800');
                    log('録音開始...', 'info');
                } catch (err) {
                    log(`マイクへのアクセスに失敗しました: ${err.message}`, 'error');
                }
            }
        };

        // --- 5. サンプル再生 ---
        function playSample(buffer, startTime = 0) {
            try {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(startTime);
            } catch (e) {
                log(`サンプル再生に失敗: ${e.message}`, 'error');
            }
        }
        
        // --- 6. MML再生エンジン (テンポ修正版) ---
        function parseConfig(cfgText) {
            const noteMap = new Map();
            const noteRegex = /^\.o([0-7])([a-g])([+#-]?)\s*=\s*(.+)$/i;
            const bankRegex = /^\.adpcm_bank=(\d+)$/i;
            let currentBank = 1;

            cfgText.split('\n').forEach(line => {
                line = line.trim();
                const bankMatch = line.match(bankRegex);
                if (bankMatch) {
                    currentBank = parseInt(bankMatch[1], 10);
                    return;
                }
                const noteMatch = line.match(noteRegex);
                if (noteMatch) {
                    const octave = parseInt(noteMatch[1], 10);
                    const note = noteMatch[2].toLowerCase();
                    const accidental = noteMatch[3]; // #, +
                    const filename = noteMatch[4].trim();
                    const noteNames = { 'c': 0, 'd': 2, 'e': 4, 'f': 5, 'g': 7, 'a': 9, 'b': 11 };
                    let noteIndex = noteNames[note];
                    if (noteIndex === undefined) return;
                    if (accidental === '#' || accidental === '+') noteIndex++;
                    // TODO: 'b' (flat)
                    
                    const midiNote = (octave * 12) + noteIndex;
                    const key = `${currentBank}-${midiNote}`;
                    
                    if (audioBuffers.has(filename)) {
                        noteMap.set(key, audioBuffers.get(filename));
                    } else {
                        log(`CFG Warning: サンプルが見つかりません: ${filename}`, 'error');
                    }
                }
            });
            return noteMap;
        }

        async function startMML() {
            if (isMMLPlaying) stopMML();
            if (!(await initAudio())) {
                log('AudioContextが起動できません。', 'error');
                return;
            }

            const batText = batEditor.value;
            const zpMatch = batText.match(/zp\s+([\w\.]+)/);
            if (!zpMatch) {
                log('BATファイルに `zp (ファイル名)` が見つかりません。', 'error');
                return;
            }
            
            const zmsFileName = zpMatch[1];
            const cfgFileName = zmsLabel.textContent === zmsFileName ? cfgLabel.textContent : zmsFileName.replace(/\.zms$/i, '.cfg');

            if (zmsFileName !== zmsLabel.textContent || cfgFileName !== cfgLabel.textContent) {
                 log(`Warning: BATの指定(${zmsFileName})とエディタのファイル名(${zmsLabel.textContent})が一致しません。`, 'error');
            }
            
            const mmlText = zmsEditor.value;
            const cfgText = cfgEditor.value;
            const noteMap = parseConfig(cfgText);

            if (noteMap.size === 0) log('CFGから音源が割り当てられませんでした。', 'error');
            log('MML再生開始...', 'success');
            isMMLPlaying = true;

            // --- MMLパーサー & スケジューラー (テンポ修正版) ---
            const loopMatch = mmlText.match(/\[L([\s\S]+)L\]/i);
            const mmlToParse = loopMatch ? loopMatch[1] : mmlText;
            const hasLoop = !!loopMatch;

            // ▼▼▼ 修正: グローバルステートをMML全体から先にスキャン ▼▼▼
            const globalState = {
                tempo: 120,
                quarterNoteTime: 0.5,
            };
            const globalTrackDefaults = {
                octave: 4,
                length: 4,
                dots: 0,
                bank: 1,
            };

            // 1. MML全体(ループの内外含む)からグローバルコマンド(t, l, o)をスキャン
            const globalCommands = mmlToParse.match(/^[ \t]*([tlo]\d+\.?)[ \t]*$/gim) || [];
            // トラック定義(A, B, ...)に属さないコマンドを先に処理
            mmlToParse.split('\n').forEach(line => {
                line = line.trim();
                if (!line || line.match(/^[A-Z]\s/i) || line.match(/^[\[L\]]/i)) {
                    return; // トラック行やループ記号は無視
                }
                // トラックに属さないコマンド (t, l, o)
                const tokens = line.split(/\s+/);
                tokens.forEach(token => {
                    const tempoMatch = token.match(/^t(\d+)$/i);
                    if (tempoMatch) {
                        globalState.tempo = parseInt(tempoMatch[1], 10);
                        globalState.quarterNoteTime = 60.0 / globalState.tempo;
                        log(`Global tempo set to ${globalState.tempo} BPM`, 'info');
                    }
                    const lengthMatch = token.match(/^l(\d+)(\.*)$/i);
                    if (lengthMatch) {
                        globalTrackDefaults.length = parseInt(lengthMatch[1], 10);
                        globalTrackDefaults.dots = lengthMatch[2] ? lengthMatch[2].length : 0;
                    }
                    const octaveMatch = token.match(/^o(\d)$/i);
                    if (octaveMatch) {
                        globalTrackDefaults.octave = parseInt(octaveMatch[1], 10);
                    }
                });
            });
            // ▲▲▲ 修正 ▲▲▲

            // 2. トラックごとにMMLを分割
            const trackLines = {};
            mmlToParse.split('\n').forEach(line => {
                line = line.trim();
                const trackMatch = line.match(/^([A-Z])\s+(.*)/i); // A o4 c d...
                if (trackMatch) {
                    const trackId = trackMatch[1].toUpperCase();
                    if (!trackLines[trackId]) trackLines[trackId] = '';
                    trackLines[trackId] += trackMatch[2] + ' '; // コマンドを連結
                }
            });

            // 3. 再帰スケジューラー
            function scheduleTracks(startTime) {
                if (!isMMLPlaying) return;
                log(`Scheduling loop at ${startTime.toFixed(2)}s`, 'info');
                
                let maxTrackTime = startTime; // ループの終端時間
                
                // テンポはグローバルステートのコピーを渡す
                // (トラック内のtコマンドで変更されても、次のループでリセットされるように)
                const currentLoopGlobalState = { ...globalState };

                for (const trackId in trackLines) {
                    const trackState = {
                        ...globalTrackDefaults, // l, o のデフォルトを継承
                        currentTime: startTime,
                    };
                    
                    // トラック内のコマンドをパース
                    const scheduledEvents = parseMML(
                        trackLines[trackId], 
                        trackState, 
                        currentLoopGlobalState, // トラック内tコマンドで変更される可能性
                        noteMap
                    );
                    
                    scheduledEvents.forEach(event => {
                        if (event.buffer) {
                            playSample(event.buffer, event.time);
                        }
                    });

                    const lastEvent = scheduledEvents.length > 0 ? scheduledEvents[scheduledEvents.length - 1] : null;
                    const trackEndTime = lastEvent ? lastEvent.time + lastEvent.duration : startTime;
                    
                    if (trackEndTime > maxTrackTime) {
                        maxTrackTime = trackEndTime;
                    }
                }

                // 4. ループ処理
                if (hasLoop && isMMLPlaying) {
                    const loopDuration = maxTrackTime - startTime;
                    if (loopDuration > 0) {
                        const nextLoopTime = maxTrackTime;
                        const delayInMs = (nextLoopTime - audioContext.currentTime) * 1000;
                        
                        mmlLoopTimeout = setTimeout(() => {
                            if (isMMLPlaying) scheduleTracks(nextLoopTime);
                        }, Math.max(0, delayInMs - 50)); // 50ms早くスケジュール
                        mmlTimeouts.push(mmlLoopTimeout);
                    } else {
                        log('ループ時間が0です。再生を停止します。', 'error');
                        isMMLPlaying = false;
                    }
                } else if (!hasLoop) {
                     const totalDurationMs = (maxTrackTime - audioContext.currentTime) * 1000;
                     mmlLoopTimeout = setTimeout(() => {
                        if (isMMLPlaying) {
                            isMMLPlaying = false; 
                            log('MML playback finished.', 'success');
                        }
                     }, Math.max(0, totalDurationMs));
                     mmlTimeouts.push(mmlLoopTimeout);
                }
            }

            // 初回実行
            scheduleTracks(audioContext.currentTime);
        }

        /**
         * 強化版MMLパーサー (テンポ修正)
         */
        function parseMML(mmlCommands, trackState, globalState, noteMap) {
            const events = [];
            const noteNames = { 'c': 0, 'd': 2, 'e': 4, 'f': 5, 'g': 7, 'a': 9, 'b': 11 };
            // T(テンポ), L(音長), O(オクターブ), <, >, Note(a-g), Rest(r)
            // [1]: Tempo, [2]: Length, [3]: Octave, [4]: <>, [5]: Note/Rest
            const regex = /(t\d+)|(l\d+\.*)|(o\d)|([<>])|([a-gr][+#-]?\d*\.*)/gi;
            let match;

            while ((match = regex.exec(mmlCommands)) !== null) {
                const token = match[0].toLowerCase();
                
                if (match[1]) { // T (Tempo)
                    globalState.tempo = parseInt(token.substring(1), 10);
                    globalState.quarterNoteTime = 60.0 / globalState.tempo;
                } 
                else if (match[2]) { // L (Length)
                    const lenMatch = token.match(/l(\d+)(\.*)?/); // l8..
                    trackState.length = parseInt(lenMatch[1], 10);
                    trackState.dots = lenMatch[2] ? lenMatch[2].length : 0;
                } 
                else if (match[3]) { // O (Octave)
                    trackState.octave = parseInt(token.substring(1), 10);
                } 
                else if (match[4]) { // < or >
                    if (token === '<') trackState.octave--;
                    if (token === '>') trackState.octave++;
                } 
                else if (match[5]) { // Note or Rest
                    const noteMatch = token.match(/([a-gr])([+#-]?)(\d*)(\.*)?/);
                    const note = noteMatch[1];
                    const accidental = noteMatch[2];
                    const lenStr = noteMatch[3];
                    const dotsStr = noteMatch[4];
                    
                    const length = lenStr ? parseInt(lenStr, 10) : trackState.length;
                    const dots = dotsStr ? dotsStr.length : (lenStr ? 0 : trackState.dots); // L8. c8 の場合、c8は付点なし
                    
                    if (length === 0) continue; // l0 や c0 は無効

                    // ▼▼▼ 修正: グローバルテンポ(globalState)を常に見る ▼▼▼
                    let duration = (4.0 / length) * globalState.quarterNoteTime;
                    // ▲▲▲ 修正 ▲▲▲
                    
                    if (dots === 1) duration *= 1.5;
                    if (dots === 2) duration *= 1.75;
                    
                    let buffer = null;
                    if (note !== 'r') {
                        let noteIndex = noteNames[note];
                        if (noteIndex !== undefined) {
                            if (accidental === '#' || accidental === '+') noteIndex++;
                            // TODO: '-' (flat)
                            const midiNote = (trackState.octave * 12) + noteIndex;
                            const key = `${trackState.bank}-${midiNote}`;
                            buffer = noteMap.get(key) || null;
                        }
                    }
                    
                    events.push({
                        time: trackState.currentTime,
                        duration: duration,
                        buffer: buffer
                    });
                    
                    trackState.currentTime += duration;
                }
            }
            return events;
        }


        function stopMML() {
            if (!isMMLPlaying) return;
            isMMLPlaying = false;
            
            mmlTimeouts.forEach(timer => clearTimeout(timer));
            mmlTimeouts = [];
            if (mmlLoopTimeout) {
                clearTimeout(mmlLoopTimeout);
                mmlLoopTimeout = null;
            }
            
            if (audioContext && audioContext.state === 'running') {
                audioContext.close().then(() => {
                    audioContext = null; 
                    log('MML再生停止。AudioContextをリセットしました。', 'info');
                });
            } else {
                 log('MML再生停止。', 'info');
            }
        }
        
        // --- 7. プロジェクトのセーブ＆ロード ---
        
        function audioBufferToWavBase64(buffer) {
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            }
            const numChannels = buffer.numberOfChannels, sampleRate = buffer.sampleRate, numSamples = buffer.length;
            const dataSize = numChannels * numSamples * 2;
            const bufferSize = 44 + dataSize;
            const ab = new ArrayBuffer(bufferSize);
            const view = new DataView(ab);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            const pcmData = new Int16Array(numSamples * numChannels);
            let offset = 0;
            for (let i = 0; i < numSamples; i++) {
                for (let c = 0; c < numChannels; c++) {
                    const channelData = buffer.getChannelData(c);
                    let s = Math.max(-1, Math.min(1, channelData[i]));
                    pcmData[offset++] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
            }
            new Uint8Array(ab, 44).set(new Uint8Array(pcmData.buffer));
            const uint8 = new Uint8Array(ab);
            return btoa(String.fromCharCode.apply(null, uint8));
        }

        async function base64ToAudioBuffer(base64) {
            if (!(await initAudio())) return null;
            try {
                const binaryString = atob(base66);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
                return await audioContext.decodeAudioData(bytes.buffer);
            } catch (e) {
                log(`Base64のデコードに失敗: ${e.message}`, 'error');
                return null;
            }
        }
        
        saveProjectButton.onclick = () => {
            log('プロジェクトを保存中...', 'info');
            try {
                const project = {
                    version: 1.1,
                    directory: dirInput.value,
                    files: {
                        playBat: { name: playBatInput.value, content: batEditor.value },
                        stopBat: { name: stopBatInput.value, content: stopBatEditor.value },
                        cfg: { name: cfgLabel.textContent, content: cfgEditor.value },
                        zms: { name: zmsLabel.textContent, content: zmsEditor.value },
                    },
                    samples: {},
                    sources: {} // ソースは容量大のため保存しない
                };
                audioBuffers.forEach((buffer, name) => {
                    project.samples[name] = audioBufferToWavBase64(buffer);
                });
                const json = JSON.stringify(project);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'web_zmusic_project.json';
                a.click();
                URL.revokeObjectURL(url);
                log('プロジェクトを保存しました。', 'success');
            } catch (e) {
                log(`プロジェクトの保存に失敗しました: ${e.message}`, 'error');
            }
        };
        
        loadProjectInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const project = JSON.parse(event.target.result);
                    if (!project.version || !project.files || !project.samples) throw new Error('無効なファイル');
                    
                    log('プロジェクトをロード中...', 'info');
                    stopMML(); // 再生中なら停止

                    dirInput.value = project.directory;
                    playBatInput.value = project.files.playBat.name;
                    batEditor.value = project.files.playBat.content;
                    stopBatInput.value = project.files.stopBat.name;
                    stopBatEditor.value = project.files.stopBat.content;
                    
                    const cfgName = project.files.cfg ? project.files.cfg.name : 'gabba.cfg';
                    const cfgContent = project.files.cfg ? project.files.cfg.content : '';
                    cfgLabel.textContent = cfgName;
                    cfgEditor.value = cfgContent;
                    
                    const zmsName = project.files.zms ? project.files.zms.name : 'gabba.zms';
                    const zmsContent = project.files.zms ? project.files.zms.content : '';
                    zmsLabel.textContent = zmsName;
                    zmsEditor.value = zmsContent;

                    updateEditorLabels();
                    audioBuffers.clear();
                    
                    const sampleNames = Object.keys(project.samples);
                    for (const name of sampleNames) {
                        try {
                            const buffer = await base64ToAudioBuffer(project.samples[name]);
                            if (buffer) audioBuffers.set(name, buffer);
                        } catch (e) {
                             log(`サンプルのデコード中にエラー: ${name}`, 'error');
                        }
                    }
                    updateSampleBankList();
                    log('プロジェクトをロードしました。', 'success');
                } catch (e) {
                    log(`プロジェクトのロードに失敗: ${e.message}`, 'error');
                } finally {
                    loadProjectInput.value = '';
                }
            };
            reader.readAsText(file);
        };
        
        // --- 8. UI連動 ---
        function updateEditorLabels() {
            const dir = dirInput.value;
            promptDisplay.textContent = `${dir}>`;
            playBatLabel.textContent = playBatInput.value;
            stopBatLabel.textContent = stopBatInput.value;
            
            const batText = batEditor.value;
            const zpMatch = batText.match(/zp\s+([\w\.]+)/);
            if (zpMatch) {
                const zmsName = zpMatch[1];
                const cfgName = zmsName.replace(/\.zms$/i, '.cfg');
                zmsLabel.textContent = zmsName;
                cfgLabel.textContent = cfgName;
            } else {
                const defaultName = playBatInput.value.replace(/\.BAT$/i, '');
                zmsLabel.textContent = `${defaultName}.zms`;
                cfgLabel.textContent = `${defaultName}.cfg`;
            }
        }
        
        dirInput.onchange = updateEditorLabels;
        playBatInput.onchange = updateEditorLabels;
        stopBatInput.onchange = updateEditorLabels;
        batEditor.onchange = updateEditorLabels;

        playButton.onclick = startMML;
        stopButton.onclick = stopMML;
        
        const tabContainer = $('tabContainer');
        const tabContents = document.querySelectorAll('.tab-content');
        const tabButtons = document.querySelectorAll('.tab-button');
        
        function switchTab(targetTab) {
            tabContents.forEach(content => {
                content.classList.toggle('active', content.id === targetTab);
            });
            tabButtons.forEach(button => {
                button.classList.toggle('border-green-400', button.dataset.tab === targetTab);
                button.classList.toggle('text-green-400', button.dataset.tab === targetTab);
                button.classList.toggle('text-gray-400', button.dataset.tab !== targetTab);
            });
        }
        
        if (tabContainer) {
            tabContainer.onclick = (e) => {
                const button = e.target.closest('.tab-button');
                if (button) switchTab(button.dataset.tab);
            };
            switchTab('tab1');
        }

        // --- 初期化処理 ---
        window.onload = () => {
            updateEditorLabels();
            updateSourceAudioList();
            updateSampleBankList();
            if (window.innerWidth >= 768) {
                tabContents.forEach(content => content.classList.add('active'));
            }
            initAudio().catch(e => console.warn(e));
        };

    </script>
</body>
</html>
