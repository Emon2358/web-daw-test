<!DOCTYPE html>
<html lang="ja" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web ZMUSIC (X68k Sampler Simulator)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* HTML/Bodyをフルハイトに */
        html, body {
            height: 100%;
            overflow: hidden; /* メインのスクロールを無効化 */
        }
        /* スクロールバーのスタイル（オプション） */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        /* タブレット/PC用のグリッドレイアウト */
        @media (min-width: 768px) {
            .main-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                gap: 0.75rem; /* gap-3 */
            }
        }
        /* スマホ用のタブUI */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body class="font-mono bg-gray-900 text-gray-200 h-full flex flex-col p-2 sm:p-4 overflow-hidden">

    <div class="w-full max-w-7xl mx-auto flex flex-col h-full">

        <!-- 1. ヘッダーとメインコントロール -->
        <header class="mb-3">
            <div class="flex flex-wrap items-center justify-between gap-2">
                <h1 class="text-xl sm:text-2xl font-bold text-green-400">Web ZMUSIC (X68k Simulator)</h1>
                <div class="flex items-center gap-2">
                    <button id="playButton" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-md shadow-lg text-white font-bold transition-all">
                        PLAY (BAT)
                    </button>
                    <button id="stopButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-md shadow-lg text-white font-bold transition-all">
                        STOP (BAT)
                    </button>
                </div>
            </div>
            <div class="text-sm text-gray-400 mt-1" id="promptDisplay">A:\CD_WORKS\gabba\></div>
        </header>

        <!-- 2. メインレイアウト（ファイル管理 + エディタ） -->
        <div class="flex-1 flex flex-col md:flex-row gap-3 overflow-hidden">

            <!-- 2-1. 左パネル: ファイル管理 -->
            <div class="w-full md:w-1/3 flex flex-col gap-3 overflow-y-auto">
                
                <!-- ディレクトリ/ファイル名編集 -->
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">Directory / Files</h2>
                    <div class="flex flex-col gap-2 text-sm">
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Dir:</label>
                            <input type="text" id="dirInput" value="A:\CD_WORKS\gabba\" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Play BAT:</label>
                            <input type="text" id="playBatInput" value="gabba.BAT" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                        <div class="flex items-center gap-2">
                            <label class="w-16 text-gray-400">Stop BAT:</label>
                            <input type="text" id="stopBatInput" value="STOP.BAT" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 focus:outline-none focus:ring-2 focus:ring-green-500">
                        </div>
                    </div>
                </div>

                <!-- 1. ソース音声のロード -->
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">1. ソース音声のロード</h2>
                    <p class="text-xs text-gray-400 mb-2">サンプリング（切り出し）用のWAV, MP3, M4A, FLAC等をロードします。</p>
                    <input type="file" id="sourceAudioUpload" multiple accept="audio/*" class="text-sm file:mr-4 file:py-1 file:px-2 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                    <div id="sourceAudioList" class="mt-2 bg-gray-900 rounded-md p-2 h-20 overflow-y-auto text-sm border border-gray-700">
                        <span class="text-gray-500">... (ここにソース音声) ...</span>
                    </div>
                </div>

                <!-- 2. 波形サンプラー (ズーム機能 復活) -->
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">2. 波形サンプラー</h2>
                    <div class="relative mb-2">
                        <canvas id="waveformCanvas" class="w-full h-24 bg-black rounded-md cursor-crosshair"></canvas>
                        <div id="selectionInfo" class="absolute bottom-1 left-1 text-xs bg-black bg-opacity-50 text-white px-1 py-0.5 rounded">
                            Drag: Select / Wheel: Pan / Ctrl+Wheel: Zoom
                        </div>
                        <!-- ズームボタン (復活) -->
                        <div class="absolute top-1 right-1 flex gap-1">
                            <button id="zoomInButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-lg leading-none">-</button>
                            <button id="zoomOutButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-lg leading-none">+</button>
                            <button id="zoomAllButton" class="w-6 h-6 bg-gray-700 hover:bg-gray-600 text-white rounded font-bold text-xs leading-none">All</button>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <input type="text" id="sampleSaveName" placeholder="保存名 (例: melo1.m44)" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-green-500">
                        <button id="saveSampleButton" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded-md text-white font-semibold text-sm">切り出し保存</button>
                    </div>
                </div>

                <!-- 3. マイク録音 -->
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">3. マイク録音</h2>
                    <div class="flex gap-2">
                        <input type="text" id="recordSaveName" placeholder="保存名 (例: voice1.m44)" class="flex-1 bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-green-500">
                        <button id="recordButton" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded-md text-white font-semibold text-sm w-20">● REC</button>
                    </div>
                </div>

                <!-- 4. サンプルバンク -->
                <div class="bg-gray-800 p-3 rounded-lg shadow-inner">
                    <h2 class="text-lg font-bold text-green-400 mb-2 border-b border-gray-700 pb-1">4. サンプルバンク (CFGから参照)</h2>
                    <label class="block mb-2">
                        <span class="text-xs text-gray-400">サンプル (WAV, MP3等) を直接バンクにロードします。</span>
                        <input type="file" id="bankAudioUpload" multiple accept="audio/*" class="text-sm w-full mt-1 file:mr-4 file:py-1 file:px-2 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700">
                    </label>
                    <div id="sampleBankList" class="mt-2 bg-gray-900 rounded-md p-2 h-24 overflow-y-auto text-sm border border-gray-700">
                        <span class="text-gray-500">... (ここにサンプル) ...</span>
                    </div>
                </div>

            </div>

            <!-- 2-2. 右パネル: エディタ -->
            <div class="flex-1 flex flex-col overflow-hidden">
                
                <!-- プロジェクト保存/読み込み -->
                <div class="flex flex-wrap gap-2 mb-3">
                    <button id="saveProjectButton" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-semibold text-sm">Save Project</button>
                    <label class="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded-md text-white font-semibold text-sm cursor-pointer">
                        <span>Load Project</span>
                        <input type="file" id="loadProjectInput" accept=".json" class="hidden">
                    </label>
                </div>

                <!-- スマホ用タブ -->
                <div class="md:hidden border-b border-gray-700 mb-2">
                    <nav class="flex -mb-px" id="tabContainer">
                        <button data-tab="tab1" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.BAT
                        </button>
                        <button data-tab="tab2" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            STOP.BAT
                        </button>
                        <button data-tab="tab3" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.cfg
                        </button>
                        <button data-tab="tab4" class="tab-button flex-1 whitespace-nowrap py-2 px-1 border-b-2 border-transparent font-medium text-sm text-gray-400 hover:text-green-400 hover:border-green-400">
                            gabba.zms
                        </button>
                    </nav>
                </div>

                <!-- エディタ本体 -->
                <div class="flex-1 main-grid overflow-hidden">
                    
                    <!-- BAT Editor -->
                    <div id="tab1" class="tab-content flex flex-col h-full min-h-[150px]">
                        <label id="playBatLabel" for="batEditor" class="text-sm text-green-400 mb-1 block">gabba.BAT</label>
                        <textarea id="batEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">pcm8pp -c8 -f7
zmusic -a -p3000
zmusic -d
zp gabba.zms
</textarea>
                    </div>

                    <!-- STOP BAT Editor -->
                    <div id="tab2" class="tab-content flex flex-col h-full min-h-[150px]">
                        <label id="stopBatLabel" for="stopBatEditor" class="text-sm text-green-400 mb-1 block">STOP.BAT</label>
                        <textarea id="stopBatEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">zp -s
zmusic -r
pcm8pp -r
</textarea>
                    </div>

                    <!-- CFG Editor -->
                    <div id="tab3" class="tab-content flex flex-col h-full min-h-[200px]">
                        <label id="cfgLabel" for="cfgEditor" class="text-sm text-green-400 mb-1 block">gabba.cfg</label>
                        <textarea id="cfgEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">/* ADPCM BANK1
.adpcm_bank=1
.o2c = kick.m44
.o2d = snar.m44
.o2f = hhc.m44
.o2f+= hho.m44
.o2a = clap.m44
.o2b = crash.m44
.o3c = melo1.m44
.o3d = melo2.m44
.o4c = voice1.m44
.o4d = voice2.m44
</textarea>
                    </div>

                    <!-- ZMS Editor -->
                    <div id="tab4" class="tab-content flex flex-col h-full min-h-[200px]">
                        <label id="zmsLabel" for="zmsEditor" class="text-sm text-green-400 mb-1 block">gabba.zms</label>
                        <textarea id="zmsEditor" class="flex-1 w-full bg-gray-800 text-white p-2 rounded-md shadow-inner border border-gray-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none">[L
t140
A o4 l8 c r c r c r c r
B o4 l8 r r d r r r d r
C o4 l8 r f r f r f r f
L]</textarea>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3. フッター (コンソールログ) -->
        <footer class="h-20 md:h-16 mt-3 overflow-y-auto bg-gray-800 p-2 rounded-md shadow-inner text-sm" id="consoleLog">
            <span class="text-gray-400">> Web ZMUSIC Simulator initialized. Ready.</span><br>
        </footer>
    </div>

    <script>
        // --- グローバル変数 ---
        let audioContext;
        let mediaRecorder;
        let recordedChunks = [];
        let audioBuffers = new Map(); // サンプルバンク (filename -> AudioBuffer)
        let sourceAudioBuffers = new Map(); // ソース音声 (filename -> AudioBuffer)
        let mmlTimeouts = []; // MML再生中のタイマー
        let mmlLoopTimeout = null; // ループ再生用のタイマー
        let isMMLPlaying = false;
        
        // 波形サンプラー用 (ズーム機能 復活)
        let currentSamplerBuffer = null;
        let selectionStartSample = 0;
        let selectionEndSample = 0;
        let isDragging = false;
        let zoomLevel = 1; // (復活)
        let viewOffset = 0; // (復活)
        
        // --- DOM取得 ---
        const $ = (selector) => document.getElementById(selector);
        const consoleLog = $('consoleLog');
        const playButton = $('playButton');
        const stopButton = $('stopButton');
        const recordButton = $('recordButton');
        const sourceAudioUpload = $('sourceAudioUpload');
        const bankAudioUpload = $('bankAudioUpload');
        const sourceAudioList = $('sourceAudioList');
        const sampleBankList = $('sampleBankList');
        const dirInput = $('dirInput');
        const playBatInput = $('playBatInput');
        const stopBatInput = $('stopBatInput');
        const playBatLabel = $('playBatLabel');
        const stopBatLabel = $('stopBatLabel');
        const cfgLabel = $('cfgLabel');
        const zmsLabel = $('zmsLabel');
        const batEditor = $('batEditor');
        const stopBatEditor = $('stopBatEditor');
        const cfgEditor = $('cfgEditor');
        const zmsEditor = $('zmsEditor');
        const promptDisplay = $('promptDisplay');
        const saveProjectButton = $('saveProjectButton');
        const loadProjectInput = $('loadProjectInput');
        const recordSaveName = $('recordSaveName');
        
        // 波形サンプラー DOM (ズーム機能 復活)
        const waveformCanvas = $('waveformCanvas');
        const canvasCtx = waveformCanvas.getContext('2d');
        const selectionInfo = $('selectionInfo');
        const sampleSaveName = $('sampleSaveName');
        const saveSampleButton = $('saveSampleButton');
        const zoomInButton = $('zoomInButton'); // (復活)
        const zoomOutButton = $('zoomOutButton'); // (復活)
        const zoomAllButton = $('zoomAllButton'); // (復活)

        // --- ログ関数 ---
        function log(message, type = 'info') {
            const color = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-green-400' : 'text-gray-400');
            consoleLog.innerHTML += `<span class="${color}">> ${message}</span><br>`;
            consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        // --- 1. オーディオ初期化 (最重要) ---
        /**
         * AudioContextを初期化または再開します。
         * ブラウザの自動再生ポリシー対策のため、ユーザー操作のたびに呼び出されます。
         */
        async function initAudio() {
            if (audioContext && audioContext.state === 'running') {
                return true; // 既に実行中
            }
            
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                if (audioContext.state !== 'running') {
                    throw new Error('AudioContext is not running.');
                }
                
                return true;
                
            } catch (e) {
                log(`AudioContextの初期化/再開に失敗しました: ${e.message}`, 'error');
                return false;
            }
        }
        
        // --- 2. 音声ファイル処理 ---

        /**
         * 汎用ファイルデコーダー
         * @param {File} file - ロードするファイル
         * @returns {Promise<{name: string, buffer: AudioBuffer}>}
         */
        async function decodeAudioFile(file) {
            if (!(await initAudio())) return null;

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        resolve({ name: file.name, buffer: audioBuffer });
                    } catch (err) {
                        log(`デコード失敗: ${file.name} - ${err.message}`, 'error');
                        reject(err);
                    }
                };
                reader.onerror = (err) => {
                    log(`ファイル読み込み失敗: ${file.name}`, 'error');
                    reject(err);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * ソース音声リストを更新
         */
        function updateSourceAudioList() {
            sourceAudioList.innerHTML = '';
            if (sourceAudioBuffers.size === 0) {
                sourceAudioList.innerHTML = '<span class="text-gray-500">... (ここにソース音声) ...</span>';
                return;
            }
            sourceAudioBuffers.forEach((buffer, name) => {
                const div = document.createElement('div');
                div.className = 'p-1 hover:bg-gray-700 cursor-pointer text-blue-300';
                div.textContent = `${name} (${buffer.duration.toFixed(2)}s)`;
                div.onclick = () => loadSourceToSampler(name);
                sourceAudioList.appendChild(div);
            });
        }
        
        /**
         * サンプルバンク（MMLから参照）リストを更新
         */
        function updateSampleBankList() {
            sampleBankList.innerHTML = '';
            if (audioBuffers.size === 0) {
                sampleBankList.innerHTML = '<span class="text-gray-500">... (ここにサンプル) ...</span>';
                return;
            }
            audioBuffers.forEach((buffer, name) => {
                const div = document.createElement('div');
                div.className = 'p-1 hover:bg-gray-700 cursor-pointer text-green-300 flex justify-between items-center';
                
                const span = document.createElement('span');
                span.textContent = `${name} (${buffer.duration.toFixed(2)}s)`;
                
                const playBtn = document.createElement('button');
                playBtn.textContent = '▶';
                playBtn.className = 'text-xs px-1 rounded bg-blue-500 hover:bg-blue-400';
                playBtn.onclick = async (e) => {
                    e.stopPropagation();
                    if (!(await initAudio())) return;
                    playSample(buffer);
                };

                div.appendChild(span);
                div.appendChild(playBtn);
                sampleBankList.appendChild(div);
            });
        }

        /**
         * [1. ソース音声のロード] (サンプラー用)
         */
        sourceAudioUpload.onchange = async (e) => {
            if (!(await initAudio())) return;
            log('ソース音声のロード中...', 'info');
            for (const file of e.target.files) {
                try {
                    const { name, buffer } = await decodeAudioFile(file);
                    sourceAudioBuffers.set(name, buffer);
                    log(`Loaded source audio: ${name}`, 'success');
                } catch (err) {
                    // エラーはdecodeAudioFile内でログ済み
                }
            }
            updateSourceAudioList();
            sourceAudioUpload.value = ''; // 次回同じファイルをロードできるように
        };

        /**
         * [4. サンプルバンクにロード] (直接ロード)
         */
        bankAudioUpload.onchange = async (e) => {
            if (!(await initAudio())) return;
            log('サンプルバンクへのロード中...', 'info');
            for (const file of e.target.files) {
                try {
                    const { name, buffer } = await decodeAudioFile(file);
                    audioBuffers.set(name, buffer);
                    log(`Loaded to bank: ${name}`, 'success');
                } catch (err) {
                    // エラーはdecodeAudioFile内でログ済み
                }
            }
            updateSampleBankList();
            bankAudioUpload.value = '';
        };

        /**
         * サンプルバンクにAudioBufferを直接追加 (録音/切り出し用)
         * @param {AudioBuffer} buffer
         * @param {string} name
         */
        function addAudioBufferToBank(buffer, name) {
            if (!name) {
                log('ファイル名が指定されていません。', 'error');
                return;
            }
            audioBuffers.set(name, buffer);
            updateSampleBankList();
            log(`「${name}」をサンプルバンクに保存しました。`, 'success');
        }

        // --- 3. 波形サンプラー (切り出し) ---

        /**
         * ソース音声をサンプラーに読み込む
         */
        function loadSourceToSampler(name) {
            const buffer = sourceAudioBuffers.get(name);
            if (!buffer) {
                log(`ソース音声が見つかりません: ${name}`, 'error');
                return;
            }
            currentSamplerBuffer = buffer;
            sampleSaveName.value = `SMPL_${name.split('.')[0]}.m44`;
            
            // ズームと選択範囲をリセット (復活)
            selectionStartSample = 0;
            selectionEndSample = buffer.length;
            zoomLevel = 1;
            viewOffset = 0;
            
            drawWaveform();
            log(`サンプラーにロード: ${name}`, 'info');
        }
        
        /**
         * 波形を描画 (ズーム機能 復活)
         */
        function drawWaveform() {
            if (!currentSamplerBuffer || !canvasCtx) return;

            const data = currentSamplerBuffer.getChannelData(0);
            const w = waveformCanvas.width;
            const h = waveformCanvas.height;

            canvasCtx.fillStyle = '#000000'; // bg-black
            canvasCtx.fillRect(0, 0, w, h);

            // 表示範囲のサンプル数を計算 (ズーム対応)
            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = Math.floor(totalSamples / zoomLevel);
            const startSample = Math.max(0, Math.floor(totalSamples * viewOffset));
            const endSample = Math.min(totalSamples, startSample + viewSamples);

            canvasCtx.lineWidth = 1;
            canvasCtx.strokeStyle = '#34d399'; // 明るい緑
            canvasCtx.beginPath();

            const step = Math.max(1, Math.floor(viewSamples / w));
            
            for (let i = 0; i < w; i++) {
                const sampleIndex = startSample + Math.floor((i / w) * viewSamples);
                
                let min = 1.0;
                let max = -1.0;
                
                // 1ピクセル分の範囲の最小値と最大値を探す
                for(let j = 0; j < step; j++) {
                    const s = data[sampleIndex + j];
                    if (s < min) min = s;
                    if (s > max) max = s;
                }

                const y_max = (max * 0.5 + 0.5) * h;
                const y_min = (min * 0.5 + 0.5) * h;

                canvasCtx.moveTo(i, y_max);
                canvasCtx.lineTo(i, y_min);
            }
            canvasCtx.stroke();

            // 選択範囲を描画 (ズーム対応)
            const selStartPixel = ((selectionStartSample - startSample) / viewSamples) * w;
            const selEndPixel = ((selectionEndSample - startSample) / viewSamples) * w;

            if (selEndPixel > selStartPixel) {
                canvasCtx.fillStyle = 'rgba(74, 222, 128, 0.4)'; // green-400 with alpha
                canvasCtx.fillRect(selStartPixel, 0, selEndPixel - selStartPixel, h);
            }
        }
        
        // リサイズ対応
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target === waveformCanvas) {
                    waveformCanvas.width = entry.contentRect.width;
                    waveformCanvas.height = entry.contentRect.height;
                    drawWaveform();
                }
            }
        });
        resizeObserver.observe(waveformCanvas);

        // サンプラーのクリック/ドラッグ操作 (ズーム対応)
        waveformCanvas.onmousedown = (e) => {
            if (!currentSamplerBuffer) return;
            isDragging = true;
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pixelRatio = x / waveformCanvas.width;

            // ズームを考慮したサンプル位置
            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = totalSamples / zoomLevel;
            const startSample = totalSamples * viewOffset;

            selectionStartSample = startSample + Math.floor(pixelRatio * viewSamples);
            selectionEndSample = selectionStartSample;
            drawWaveform();
        };

        waveformCanvas.onmousemove = (e) => {
            if (!isDragging || !currentSamplerBuffer) return;
            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const pixelRatio = x / waveformCanvas.width;

            // ズームを考慮したサンプル位置
            const totalSamples = currentSamplerBuffer.length;
            const viewSamples = totalSamples / zoomLevel;
            const startSample = totalSamples * viewOffset;
            
            selectionEndSample = startSample + Math.floor(pixelRatio * viewSamples);
            
            // 選択範囲が逆にならないように (スワップ)
            if (selectionEndSample < selectionStartSample) {
                let temp = selectionStartSample;
                selectionStartSample = selectionEndSample;
                selectionEndSample = temp;
            }
            
            drawWaveform();
        };

        window.onmouseup = () => {
            if (isDragging) {
                isDragging = false;
                drawWaveform(); // 最終的な選択範囲で再描画
            }
        };

        // サンプラーのズーム/パン操作 (復活)
        waveformCanvas.onwheel = (e) => {
            e.preventDefault();
            if (!currentSamplerBuffer) return;

            if (e.ctrlKey) {
                // ズーム (Ctrl + Wheel)
                const rect = waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const mousePosRatio = x / waveformCanvas.width; // 0.0 - 1.0
                
                const delta = e.deltaY < 0 ? 1.25 : 0.8; // ズーム率 (ホイールの方向を反転)
                const newZoomLevel = Math.max(1, Math.min(zoomLevel * delta, currentSamplerBuffer.length / 100)); // 最小100サンプルまで

                if (newZoomLevel === zoomLevel) return;

                // ズーム中心をマウスカーソル位置に合わせる
                const viewSamples = currentSamplerBuffer.length / zoomLevel;
                const mouseSample = (currentSamplerBuffer.length * viewOffset) + (mousePosRatio * viewSamples);
                
                zoomLevel = newZoomLevel;
                
                const newViewSamples = currentSamplerBuffer.length / zoomLevel;
                viewOffset = (mouseSample - (mousePosRatio * newViewSamples)) / currentSamplerBuffer.length;

            } else {
                // パン (Wheel)
                const delta = e.deltaY > 0 ? 0.05 : -0.05;
                viewOffset += delta / zoomLevel;
            }

            // viewOffsetの範囲を制限
            const maxViewOffset = 1.0 - (1.0 / zoomLevel);
            viewOffset = Math.max(0, Math.min(viewOffset, maxViewOffset));
            
            drawWaveform();
        };

        // ズームボタン (復活)
        zoomInButton.onclick = () => { // - (縮小)
            if (!currentSamplerBuffer) return;
            zoomLevel = Math.max(1, zoomLevel / 1.5);
            viewOffset = Math.min(viewOffset, 1.0 - (1.0 / zoomLevel)); // オフセット調整
            drawWaveform();
        };
        zoomOutButton.onclick = () => { // + (拡大)
            if (!currentSamplerBuffer) return;
            zoomLevel = Math.min(currentSamplerBuffer.length / 100, zoomLevel * 1.5);
            drawWaveform();
        };
        zoomAllButton.onclick = () => {
            if (!currentSamplerBuffer) return;
            zoomLevel = 1;
            viewOffset = 0;
            drawWaveform();
        };

        /**
         * [切り出し保存] ボタン
         */
        saveSampleButton.onclick = async () => {
            if (!currentSamplerBuffer) {
                log('サンプラーにソース音声がロードされていません。', 'error');
                return;
            }
            if (selectionStartSample === selectionEndSample) {
                log('切り出し範囲が選択されていません。', 'error');
                return;
            }
            if (!sampleSaveName.value) {
                log('保存ファイル名を入力してください。', 'error');
                return;
            }

            if (!(await initAudio())) return;

            // 選択範囲が逆転していても大丈夫なように
            const start = Math.min(selectionStartSample, selectionEndSample);
            const end = Math.max(selectionStartSample, selectionEndSample);
            const length = end - start;
            
            if (length <= 0) {
                 log('切り出し範囲がありません。', 'error');
                return;
            }

            const channels = currentSamplerBuffer.numberOfChannels;
            const rate = currentSamplerBuffer.sampleRate;

            try {
                const newBuffer = audioContext.createBuffer(channels, length, rate);

                for (let i = 0; i < channels; i++) {
                    const oldData = currentSamplerBuffer.getChannelData(i);
                    const newData = newBuffer.getChannelData(i);
                    newData.set(oldData.subarray(start, end));
                }
                
                addAudioBufferToBank(newBuffer, sampleSaveName.value);

            } catch (e) {
                log(`切り出しに失敗しました: ${e.message}`, 'error');
            }
        };

        // --- 4. マイク録音 ---
        recordButton.onclick = async () => {
            if (!(await initAudio())) return;

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // 停止処理
                mediaRecorder.stop();
                recordButton.textContent = '● REC';
                recordButton.classList.remove('animate-pulse', 'bg-red-800');
                log('録音を停止しました。', 'info');
            } else {
                // 開始処理
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };

                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(recordedChunks, { type: 'audio/wav' });
                        const arrayBuffer = await blob.arrayBuffer();
                        
                        if (!(await initAudio())) return;

                        try {
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                            const saveName = recordSaveName.value || `REC_${new Date().toISOString()}.wav`;
                            addAudioBufferToBank(audioBuffer, saveName);
                        } catch(e) {
                            log(`録音データのデコードに失敗しました: ${e.message}`, 'error');
                        }
                        
                        // ストリームを停止
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    recordButton.textContent = '■ STOP';
                    recordButton.classList.add('animate-pulse', 'bg-red-800');
                    log('録音開始...', 'info');

                } catch (err) {
                    log(`マイクへのアクセスに失敗しました: ${err.message}`, 'error');
                }
            }
        };

        // --- 5. サンプル再生 ---
        /**
         * AudioBufferを再生（プレビュー/MML再生用）
         * @param {AudioBuffer} buffer 
         * @param {number} startTime (オプション) AudioContextの開始時間
         */
        function playSample(buffer, startTime = 0) {
            try {
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(startTime);
            } catch (e) {
                log(`サンプル再生に失敗: ${e.message}`, 'error');
            }
        }
        
        // --- 6. MML再生エンジン (ループ機能 搭載) ---
        
        // .cfgファイル（ノート割り当て）をパース
        function parseConfig(cfgText) {
            const noteMap = new Map();
            // .m44 だけでなく、一般的な音声拡張子も許可する
            const noteRegex = /^\.o([0-7])([a-g])([+#-]?)\s*=\s*(.+)$/i;
            const bankRegex = /^\.adpcm_bank=(\d+)$/i;
            
            let currentBank = 1;
            
            cfgText.split('\n').forEach(line => {
                line = line.trim();
                
                const bankMatch = line.match(bankRegex);
                if (bankMatch) {
                    currentBank = parseInt(bankMatch[1], 10);
                    return;
                }
                
                const noteMatch = line.match(noteRegex);
                if (noteMatch) {
                    const octave = parseInt(noteMatch[1], 10);
                    const note = noteMatch[2].toLowerCase();
                    const accidental = noteMatch[3]; // #, + (TODO: 未実装)
                    const filename = noteMatch[4].trim();
                    
                    // ZMUSICのノート番号 (o0c = 0)
                    const noteNames = { 'c': 0, 'd': 2, 'e': 4, 'f': 5, 'g': 7, 'a': 9, 'b': 11 };
                    const noteIndex = noteNames[note];
                    if (noteIndex === undefined) return;
                    
                    const midiNote = (octave * 12) + noteIndex;
                    
                    const key = `${currentBank}-${midiNote}`;
                    
                    if (audioBuffers.has(filename)) {
                        noteMap.set(key, audioBuffers.get(filename));
                    } else {
                        log(`CFG Warning: サンプルが見つかりません: ${filename}`, 'error');
                    }
                }
            });
            return noteMap;
        }

        // MMLをパースして再生 (高機能版)
        async function startMML() {
            if (isMMLPlaying) {
                stopMML();
            }
            
            if (!(await initAudio())) {
                log('AudioContextが起動できません。再生を開始できません。', 'error');
                return;
            }

            // 1. BATファイルから .zms と .cfg ファイル名を取得
            const batText = batEditor.value;
            const zpMatch = batText.match(/zp\s+([\w\.]+)/);
            if (!zpMatch) {
                log('BATファイルに `zp (ファイル名)` が見つかりません。', 'error');
                return;
            }
            const zmsFileName = zpMatch[1];
            
            // zms/cfgがエディタ上のファイル名と一致するかチェック (簡易的)
            if (zmsFileName !== zmsLabel.textContent) {
                log(`BATが指定する ${zmsFileName} は ${zmsLabel.textContent} と一致しません。`, 'error');
                // TODO: 本来はファイル名ベースでエディタを切り替えるべき
            }
            
            const cfgFileName = zmsFileName.replace(/\.zms$/i, '.cfg');
            if (cfgFileName !== cfgLabel.textContent) {
                 log(`CFG Warning: ${cfgFileName} (推定) が ${cfgLabel.textContent} (現在) と一致しません。`, 'error');
            }

            const mmlText = zmsEditor.value;
            const cfgText = cfgEditor.value;
            
            const noteMap = parseConfig(cfgText);
            if (noteMap.size === 0) {
                log('CFGから音源が割り当てられませんでした。', 'error');
                return;
            }

            log('MML再生開始...', 'success');
            isMMLPlaying = true;
            
            // --- MMLパーサー & スケジューラー ---
            
            // 状態管理
            const tracks = {}; // トラックごとの状態 (A, B, C...)
            const trackLines = {}; // トラックごとのMML行
            let globalTempo = 120;
            
            // MMLの前処理 (ループとトラック分割)
            const loopMatch = mmlText.match(/\[L([\s\S]+)L\]/i);
            const mmlToParse = loopMatch ? loopMatch[1] : mmlText;
            const hasLoop = !!loopMatch;

            mmlToParse.split('\n').forEach(line => {
                line = line.trim();
                const trackMatch = line.match(/^([A-Z])\s+(.*)/i); // A o4 c d e
                const tempoMatch = line.match(/^t(\d+)/i); // t120
                
                if (trackMatch) {
                    const trackId = trackMatch[1].toUpperCase();
                    const commands = trackMatch[2];
                    if (!trackLines[trackId]) trackLines[trackId] = [];
                    trackLines[trackId].push(commands);
                } else if (tempoMatch) {
                    globalTempo = parseInt(tempoMatch[1], 10);
                }
            });

            // 60BPMの4分音符の秒数
            const quarterNoteTime = 60.0 / globalTempo;

            function getNoteDuration(l, dots) {
                let duration = (4.0 / l) * quarterNoteTime;
                if (dots === 1) duration *= 1.5;
                if (dots === 2) duration *= 1.75;
                return duration;
            }

            // 再帰的なスケジューリング関数
            function scheduleTracks(startTime) {
                if (!isMMLPlaying) return; // 停止していたらスケジューリングしない

                log(`Scheduling loop at ${startTime.toFixed(2)}s`, 'info');
                
                let maxTrackTime = 0;

                // 各トラックを独立して処理
                for (const trackId in trackLines) {
                    let T = {
                        octave: 4,
                        length: 4, // デフォルト4分音符
                        bank: 1, // TODO: .adpcm_bank=N に対応
                        currentTime: startTime, // このトラックの現在のタイムライン (AudioContext時間)
                    };
                    
                    const mmlCommands = trackLines[trackId].join(' ');
                    const tokens = mmlCommands.match(/[a-g][+#-]?\d*\.*|r\d*\.*|o\d|<|>|l\d*\.*|t\d+/gi) || [];

                    for (const token of tokens) {
                        if (!isMMLPlaying) break; // 処理中に停止された
                        
                        let note, len, dots;
                        
                        const noteMatch = token.match(/^([a-g][+#-]?|r)(\d*)(\.*)/i);
                        if (noteMatch) {
                            note = noteMatch[1].toLowerCase();
                            len = noteMatch[2] ? parseInt(noteMatch[2], 10) : T.length;
                            dots = noteMatch[3].length;

                            const duration = getNoteDuration(len, dots);

                            if (note !== 'r') {
                                // ノートを再生
                                const noteNames = { 'c': 0, 'd': 2, 'e': 4, 'f': 5, 'g': 7, 'a': 9, 'b': 11 };
                                const noteIndex = noteNames[note[0]];
                                // TODO: # + -
                                
                                if (noteIndex !== undefined) {
                                    const midiNote = (T.octave * 12) + noteIndex;
                                    const key = `${T.bank}-${midiNote}`;
                                    
                                    if (noteMap.has(key)) {
                                        playSample(noteMap.get(key), T.currentTime);
                                    }
                                }
                            }
                            
                            T.currentTime += duration; // 次のノートの開始時間を更新
                        
                        } else if (token.match(/^o\d/i)) {
                            T.octave = parseInt(token.substring(1), 10);
                        } else if (token === '<') {
                            T.octave--;
                        } else if (token === '>') {
                            T.octave++;
                        } else if (token.match(/^l\d*/i)) {
                            const lenMatch = token.match(/^l(\d*)(\.*)/i);
                            T.length = lenMatch[1] ? parseInt(lenMatch[1], 10) : T.length;
                            // TODO: Lに付点 . (ZMUSIC仕様？)
                        } else if (token.match(/^t\d+/i)) {
                            // TODO: テンポチェンジ (グローバルテンポの変更は複雑)
                        }
                    }
                    
                    // このトラックの終了時間
                    if (T.currentTime > maxTrackTime) {
                        maxTrackTime = T.currentTime;
                    }
                } // End for (trackId)

                // ループ処理
                if (hasLoop && isMMLPlaying) {
                    const loopDuration = maxTrackTime - startTime;
                    if (loopDuration > 0) {
                        const delayInMs = (maxTrackTime - audioContext.currentTime) * 1000;
                        
                        // 次のループをスケジュール
                        mmlLoopTimeout = setTimeout(() => {
                            if (isMMLPlaying) {
                                scheduleTracks(maxTrackTime); // 次のループを開始
                            }
                        }, Math.max(0, delayInMs - 50)); // 50ms早くスケジュールして途切れを防止
                        
                        mmlTimeouts.push(mmlLoopTimeout);
                    } else {
                        log('ループ時間が0です。ループを停止します。', 'error');
                    }
                }
            } // End scheduleTracks

            // 初回実行
            scheduleTracks(audioContext.currentTime);

        } // End startMML

        function stopMML() {
            if (!isMMLPlaying) return;
            
            isMMLPlaying = false;
            
            // スケジュールされたすべてのノートとループをキャンセル
            mmlTimeouts.forEach(timer => clearTimeout(timer));
            mmlTimeouts = [];
            if (mmlLoopTimeout) {
                clearTimeout(mmlLoopTimeout);
                mmlLoopTimeout = null;
            }
            
            // 現在再生中の音を止める (Web Audio APIでは難しいが、擬似的に)
            // AudioContextを止めて再起動するのが確実
            if (audioContext) {
                audioContext.close().then(() => {
                    audioContext = null; // initAudio() で再作成される
                    log('MML再生停止。AudioContextをリセットしました。', 'info');
                });
            } else {
                 log('MML再生停止。', 'info');
            }
        }
        
        // --- 7. プロジェクトのセーブ＆ロード ---
        
        /**
         * AudioBufferをWAV (Base64) に変換
         * (簡易エンコーダー)
         */
        function audioBufferToWavBase64(buffer) {
            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            function floatTo16BitPCM(output, offset, input) {
                for (let i = 0; i < input.length; i++, offset += 2) {
                    let s = Math.max(-1, Math.min(1, input[i]));
                    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
            }

            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const numSamples = buffer.length;
            const dataSize = numChannels * numSamples * 2; // 16-bit PCM

            const bufferSize = 44 + dataSize;
            const ab = new ArrayBuffer(bufferSize);
            const view = new DataView(ab);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true); // file-size - 8
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // PCM
            view.setUint16(20, 1, true); // 1 = PCM
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true); // byteRate
            view.setUint16(32, numChannels * 2, true); // blockAlign
            view.setUint16(34, 16, true); // bitsPerSample
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // チャンネルデータをインターリーブ
            const pcmData = new DataView(new ArrayBuffer(dataSize));
            let offset = 0;
            const channelsData = [];
            for (let i = 0; i < numChannels; i++) {
                channelsData.push(buffer.getChannelData(i));
            }
            
            for (let i = 0; i < numSamples; i++) {
                for (let c = 0; c < numChannels; c++) {
                    let s = Math.max(-1, Math.min(1, channelsData[c][i]));
                    pcmData.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            // DataViewのデータをArrayBufferのUint8Arrayとしてコピー
            new Uint8Array(ab, 44).set(new Uint8Array(pcmData.buffer));

            // Base64エンコード
            const uint8 = new Uint8Array(ab);
            const base64 = btoa(String.fromCharCode.apply(null, uint8));
            return base64;
        }

        /**
         * Base64 (WAV) を AudioBufferに変換
         */
        async function base64ToAudioBuffer(base64) {
            if (!(await initAudio())) return null;
            try {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const arrayBuffer = bytes.buffer;
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (e) {
                log(`Base64のデコードに失敗: ${e.message}`, 'error');
                return null;
            }
        }
        
        // [Save Project]
        saveProjectButton.onclick = () => {
            log('プロジェクトを保存中...', 'info');
            try {
                const project = {
                    version: 1,
                    directory: dirInput.value,
                    files: {
                        playBat: { name: playBatInput.value, content: batEditor.value },
                        stopBat: { name: stopBatInput.value, content: stopBatEditor.value },
                        cfg: { name: cfgLabel.textContent, content: cfgEditor.value },
                        zms: { name: zmsLabel.textContent, content: zmsEditor.value },
                    },
                    samples: {},
                    sources: {} // ソース音声は保存しない (容量が大きすぎるため)
                };
                
                // サンプルバンクの音声をBase64に
                audioBuffers.forEach((buffer, name) => {
                    project.samples[name] = audioBufferToWavBase64(buffer);
                });

                const json = JSON.stringify(project);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'web_zmusic_project.json';
                a.click();
                URL.revokeObjectURL(url);
                log('プロジェクトを保存しました。', 'success');

            } catch (e) {
                log(`プロジェクトの保存に失敗しました: ${e.message}`, 'error');
            }
        };
        
        // [Load Project]
        loadProjectInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const json = event.target.result;
                    const project = JSON.parse(json);

                    if (!project.version || !project.files || !project.samples) {
                        throw new Error('無効なプロジェクトファイルです。');
                    }
                    
                    log('プロジェクトをロード中...', 'info');
                    stopMML(); // 再生中のMMLを停止

                    // エディタの内容を復元
                    dirInput.value = project.directory;
                    playBatInput.value = project.files.playBat.name;
                    batEditor.value = project.files.playBat.content;
                    stopBatInput.value = project.files.stopBat.name;
                    stopBatEditor.value = project.files.stopBat.content;
                    
                    // cfg/zmsは名前も復元
                    const cfgName = project.files.cfg ? project.files.cfg.name : 'gabba.cfg';
                    const cfgContent = project.files.cfg ? project.files.cfg.content : '';
                    cfgLabel.textContent = cfgName;
                    cfgEditor.value = cfgContent;
                    
                    const zmsName = project.files.zms ? project.files.zms.name : 'gabba.zms';
                    const zmsContent = project.files.zms ? project.files.zms.content : '';
                    zmsLabel.textContent = zmsName;
                    zmsEditor.value = zmsContent;

                    // UIを更新
                    updateEditorLabels();
                    
                    // サンプルバンクをクリア
                    audioBuffers.clear();
                    
                    // サンプルをデコードして復元
                    const sampleNames = Object.keys(project.samples);
                    for (const name of sampleNames) {
                        const base64 = project.samples[name];
                        try {
                            const buffer = await base64ToAudioBuffer(base64);
                            if (buffer) {
                                audioBuffers.set(name, buffer);
                            } else {
                                log(`サンプルのデコードに失敗: ${name}`, 'error');
                            }
                        } catch (e) {
                             log(`サンプルのデコード中にエラー: ${name}`, 'error');
                        }
                    }
                    
                    updateSampleBankList();
                    log('プロジェクトをロードしました。', 'success');
                    
                } catch (e) {
                    log(`プロジェクトのロードに失敗しました: ${e.message}`, 'error');
                } finally {
                    loadProjectInput.value = ''; // 次回同じファイルをロードできるように
                }
            };
            reader.readAsText(file);
        };
        
        // --- 8. UI連動 ---

        // ファイル名入力とエディタラベル/Promptを連動
        function updateEditorLabels() {
            const dir = dirInput.value;
            promptDisplay.textContent = `${dir}>`;
            
            playBatLabel.textContent = playBatInput.value;
            stopBatLabel.textContent = stopBatInput.value;
            
            // BAT内のファイル名から CFG/ZMS のラベルを推測
            const batText = batEditor.value;
            const zpMatch = batText.match(/zp\s+([\w\.]+)/);
            if (zpMatch) {
                const zmsName = zpMatch[1];
                const cfgName = zmsName.replace(/\.zms$/i, '.cfg');
                zmsLabel.textContent = zmsName;
                cfgLabel.textContent = cfgName;
            } else {
                zmsLabel.textContent = 'gabba.zms';
                cfgLabel.textContent = 'gabba.cfg';
            }
        }
        
        dirInput.onchange = updateEditorLabels;
        playBatInput.onchange = updateEditorLabels;
        stopBatInput.onchange = updateEditorLabels;
        batEditor.onchange = updateEditorLabels; // BAT編集時もラベル更新

        // メインコントロールボタン
        playButton.onclick = startMML;
        stopButton.onclick = stopMML;
        
        // スマホ用タブ切り替え
        const tabContainer = $('tabContainer');
        const tabContents = document.querySelectorAll('.tab-content');
        const tabButtons = document.querySelectorAll('.tab-button');
        
        function switchTab(targetTab) {
            tabContents.forEach(content => {
                if (content.id === targetTab) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });
            tabButtons.forEach(button => {
                if (button.dataset.tab === targetTab) {
                    button.classList.add('border-green-400', 'text-green-400');
                } else {
                    button.classList.remove('border-green-400', 'text-green-400');
                }
            });
        }
        
        if (tabContainer) {
            tabContainer.onclick = (e) => {
                const button = e.target.closest('.tab-button');
                if (button) {
                    switchTab(button.dataset.tab);
                }
            };
            // 初期タブを設定
            switchTab('tab1');
        }

        // --- 初期化処理 ---
        window.onload = () => {
            updateEditorLabels();
            updateSourceAudioList();
            updateSampleBankList();
            
            // PC表示（md以上）の場合は全タブを強制的にアクティブ化
            if (window.innerWidth >= 768) {
                tabContents.forEach(content => {
                    content.classList.add('active');
                });
            }
        };

    </script>
</body>
</html>
